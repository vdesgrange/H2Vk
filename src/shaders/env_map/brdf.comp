#version 460
#extension GL_GOOGLE_include_directive : enable

#include "../common/brdf.glsl"

layout(binding = 0, rgba16f) writeonly uniform image2D outputImage; // brdf

layout(local_size_x = 32, local_size_y = 32) in;

/**
* Environment BRDF - Pre-compute LUT
* [Real Shading in Unreal Engine 4 - Epic Games]
*/
vec2 BRDF(float dotNV, float roughness) {
    uint totalSamples = 1024u;
    vec3 V = vec3(sqrt(1.0 - dotNV * dotNV), 0.0, dotNV);
    vec3 N = vec3(0.0, 0.0, 1.0);

    float A = 0.0;
    float B = 0.0;

    for(uint i = 0u; i < totalSamples; i++) {
        vec2 Xi = hammersley(i, totalSamples);
        vec3 H  = importance_sample_GGX(N, Xi, roughness);
        vec3 L  = normalize(2.0 * dot(V, H) * H - V);

        float dotNL = clamp(L.z, 0.0, 1.0); // N = vec3(0.0, 0.0, 1.0);
        float dotNH = clamp(H.z, 0.0, 1.0);
        float dotVH = clamp(dot(V, H), 0.0, 1.0);

        if(dotNL > 0.0) {
            float G = G_IBL_GGX(dotNL, dotNV, roughness);
            float G_Vis = (G * dotVH) / (dotNH * dotNV);
            float Fc = pow(1.0 - dotVH, 5.0);

            A += (1.0 - Fc) * G_Vis;
            B += Fc * G_Vis;
        }
    }

    return vec2(A, B) / float(totalSamples);
}

void main()
{
    ivec2 outSize = imageSize(outputImage);
    float texSize = float(outSize[0]); // square

    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    float dotNV = float(texCoord.x + 1.0) * 1.0 / texSize;
    float roughness = float(texCoord.y + 1.0) * 1.0 / texSize;

    // Compute Look-up table
    vec2 LUT = BRDF(dotNV, roughness);

    imageStore(outputImage, texCoord, vec4(LUT, 0.0, 0.0));
}