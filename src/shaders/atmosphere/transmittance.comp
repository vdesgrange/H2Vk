#version 460
#extension GL_GOOGLE_include_directive : enable

#include "./functions.glsl"

layout(set = 0, binding = 0, rgba16f) writeonly uniform image2D outputImage;

layout(local_size_x = 32, local_size_y = 32) in;

vec3 get_transmittance(vec3 x, vec3 sun_dir) {
    vec3 T = vec3(1.0);
    int SAMPLE_COUNT = 40;
    float bias = 0.3;

    if (get_ray_intersection_length(x, sun_dir, r_ground) > 0.0) {
        return vec3(0.0);
    }

    float t_atmo = get_ray_intersection_length(x, sun_dir, r_top);
    float t = 0.0;
    float dt = t_atmo / SAMPLE_COUNT;

    for (int k = 0; k < SAMPLE_COUNT; k++) {
        float new_t = t_atmo * (k + bias) / SAMPLE_COUNT;
        dt = new_t - t;
        t = new_t;

        vec3 x_tv = x + t * sun_dir; // x - tv

        vec3 beta_s = vec3(0.0);
        vec3 beta_a = vec3(0.0);
        vec3 beta_e = vec3(0.0);
        get_beta_coefficients(x_tv, beta_s, beta_a, beta_e);

        vec3 sample_T = exp(-dt * beta_e);
        T *= sample_T;
    }

    return T;
}

void main() {
    vec2 texSize = vec2(imageSize(outputImage));
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv =  vec2(gl_GlobalInvocationID.xy) / texSize;

    float height = uv.y * (r_top - r_ground) + r_ground;
    float zenithSunCosTheta = 2.0 * uv.x - 1.0; // mu_s cosinus zenith and sun angle
    float zenithSunSinTheta = sqrt(clamp(1.0 - zenithSunCosTheta * zenithSunCosTheta, 0.0, 1.0));

    vec3 x = vec3(0.0, height, 0.0);
    vec3 sun_dir = normalize(vec3(0.0, zenithSunCosTheta, -zenithSunSinTheta));
    vec3 transmittance = get_transmittance(x, sun_dir);

    imageStore(outputImage, texCoord, vec4(transmittance, 1.0));
}